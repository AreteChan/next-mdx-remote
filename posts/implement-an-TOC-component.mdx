---
title: 实现博客目录 TOC 组件
date: 2024-10-07T16:19:55+08:00
description: 实现一个博客目录 TOC(Table of Contents) 组件，解析 IntersectionObserver 的使用。
keywords: [React, Next.js, useEffect, IntersectionObserver]
---


博客目录 TOC 组件，用于展示博客文章的目录结构，并根据用户浏览位置高亮目录中的对应标题。

**实现思路：**
1. 从 Markdown 文档中提取标题（1级 ~ 3级标题），确定 HTML 结构；
2. 使用 IntersectionObserver 监听标题元素的滚动位置和滚动方向，计算哪个标题需要高亮；
3. 使用 useState 更新标题高亮状态。

## 提取 Markdown 标题
为避免代码块干扰，先使用正则表达式去除代码块，再匹配 Markdown 标题。

匹配 Markdown 标题的正则表达式使用 `/m` 多行匹配，会将开始和结束字符 (`^`and `$`) 视为在多行上工作，从而正确识别出某行开头的 `#` 字符。

```TypeScript
export function getMarkdownTitles(slug: string) {
  const post = getPostBySlug(slug) // 获取文章

  const mdText = post.content;
  // 清除代码块
  const codeRegex = /```[\s\S]*?```/g; // 使用 [\s\S] 代替 . 并去掉 s 标志
  const mdTextNoCode = mdText.replace(codeRegex, '');

  // 匹配 Markdown 标题
  const titleRegex = /^#{1,3}\s.+/gm; // 匹配 1 到 3 个 # 开头的行
  const titles = mdTextNoCode.match(titleRegex) || []; // match没有匹配返回null
  return titles;
}
```

匹配出标题后，便可以编写 HTML，这里使用 a 标签包裹标题字符串，href 属性通过锚点跳转到对应 id 元素的位置。

```TypeScript
titles.map((title: string) => {
  const pureTitle = title.replace(/^#{1,3}\s/, '');
  let className = "block text-slate-500 hover:text-slate-900 dark:text-slate-200 dark:hover:text-slate-400 whitespace-nowrap ";

  // 设置不同的 margin 展示标题层级关系
  if (title.startsWith("## ")) className += "ml-2 ";
  else if (title.startsWith("### ")) className += "ml-4 ";

  return (
    <a
      key={title}
      href={`#${pureTitle}`}
      className={className}
    >
      {pureTitle}
    </a>
  );
})
```

## IntersectionObserver 监听元素滚动
`IntersectionObserver`（交叉观察器）可以监听目标元素对视口与根元素的相交状态，并执行相应操作。

它是一个构造函数，接收两个参数 `callback` 和 `options`。

```TypeScript
const observer = new IntersectionObserver(observerCallback, observerOptions);
```

### callback 详解

在 `IntersectionObserver` API 中，`callback` 会在以下情况被调用：
- 目标元素与设备视口或指定的根元素相交状态变化（不相交 -> 相交 or 相交 -> 不相交）；
- 观察器（Observer）第一次监听观察目标元素。

`callback` 接收一个 `entries: IntersectionObserverEntry[]` 参数